<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>tengyuanjack&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-01-02T12:26:51.886Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tomcat的ClassLoader</title>
    <link href="http://yoursite.com/2020/01/02/java/Tomcat%E7%9A%84ClassLoader/"/>
    <id>http://yoursite.com/2020/01/02/java/Tomcat的ClassLoader/</id>
    <published>2020-01-02T11:42:51.000Z</published>
    <updated>2020-01-02T12:26:51.886Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="Tomcat的classloader"><a href="#Tomcat的classloader" class="headerlink" title="Tomcat的classloader"></a>Tomcat的classloader</h2><h2 id="遇到的项目问题及排查过程"><a href="#遇到的项目问题及排查过程" class="headerlink" title="遇到的项目问题及排查过程"></a>遇到的项目问题及排查过程</h2><p>项目中需要动态编译类，所以用到了jdk中的tools.jar（见<a href>如何在代码中编译java类</a>)，此前项目一直用中间件服务的形式启动，启动脚本中指定了jdk，没有任何问题。后来将项目打成了war包放在原生tomcat中执行，出现了找不到tools.jar中类的错误。</p><p>排查过程如下：</p><ol><li>查看启动日志，发现如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">信息 [main] org.apache.catalina.startup.VersionLoggerListener.log Java Home:             /usr/local/java/jre</span><br></pre></td></tr></table></figure></li></ol><p>用的是JRE_HOME，只有运行时环境，当然就没有工具类了；</p><ol start="2"><li>需要重新指定java home，于是依次查看 <code>startup.sh</code>-&gt;<code>catalina.sh</code>-&gt;<code>setclasspath.sh</code>，看到了如下解释：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#   JAVA_HOME       Must point at your Java Development Kit installation.</span><br><span class="line">#                   Required to run the with the &quot;debug&quot; argument.</span><br><span class="line">#</span><br><span class="line">#   JRE_HOME        Must point at your Java Runtime installation.</span><br><span class="line">#                   Defaults to JAVA_HOME if empty. If JRE_HOME and JAVA_HOME</span><br><span class="line">#                   are both set, JRE_HOME is used.</span><br></pre></td></tr></table></figure></li></ol><p>当环境变量中JRE_HOME和JAVA_HOME都设置，且不是debug模式时，使用JRE_HOME。</p><p>从而发现问题所在。</p><ol start="3"><li>在setclasspath.sh中将JRE_HOME显式指定为JAVA_HOME即可，<code>JRE_HOME=&quot;$JAVA_HOME&quot;</code>。  但是由于项目中不允许更改容器的内容，故采取取巧的方式，将基础镜像中的JRE_HOME环境变量去掉。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Tomcat的classloader&quot;&gt;&lt;a href=&quot;#Tomcat的classloader&quot; class=&quot;headerlink&quot; title=&quot;Tomcat的classloader&quot;&gt;&lt;/a&gt;Tomcat的classlo
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="tomcat" scheme="http://yoursite.com/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>自定义ClassLoader的编写和使用</title>
    <link href="http://yoursite.com/2020/01/02/java/%E8%87%AA%E5%AE%9A%E4%B9%89ClassLoader%E7%9A%84%E7%BC%96%E5%86%99%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/01/02/java/自定义ClassLoader的编写和使用/</id>
    <published>2020-01-02T11:37:47.000Z</published>
    <updated>2020-01-02T14:25:00.558Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲解ClassLoader的含义、jvm类加载机制、ClassLoader类解读和实例。</p><a id="more"></a><h2 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h2><h2 id="java虚拟机类加载机制"><a href="#java虚拟机类加载机制" class="headerlink" title="java虚拟机类加载机制"></a>java虚拟机类加载机制</h2><h2 id="ClassLoader类代码解读"><a href="#ClassLoader类代码解读" class="headerlink" title="ClassLoader类代码解读"></a>ClassLoader类代码解读</h2><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>自定义ClassLoader，需要继承ClassLoader，至少重写findClass(String)方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 自定义类加载器，只支持class文件</span><br><span class="line"> */</span><br><span class="line">public class MyClassLoader extends ClassLoader &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 类路径</span><br><span class="line">     */</span><br><span class="line">    private String classPath;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 资源路径</span><br><span class="line">     */</span><br><span class="line">    private String resourcePath;</span><br><span class="line"></span><br><span class="line">    private static MyClassLoader instance = null;</span><br><span class="line"></span><br><span class="line">    public MyClassLoader(String classPath, String resourcePath) &#123;</span><br><span class="line">        this.classPath = classPath;</span><br><span class="line">        this.resourcePath = resourcePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 同步</span><br><span class="line">     */</span><br><span class="line">    public static synchronized MyClassLoader getMyClassLoader(String classPath, String resourcePath) &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new MyClassLoader(classPath, resourcePath);</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重写该方法，该方法在父类ClassLoader.loadClass(String)中调用</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        // 已加载，直接使用</span><br><span class="line">        Class&lt;?&gt; clz = super.findLoadedClass(name);</span><br><span class="line">        if (clz != null) &#123;</span><br><span class="line">            return clz;</span><br><span class="line">        &#125;</span><br><span class="line">        // 手动加载classPath中的类</span><br><span class="line">        return loadMyClass(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Class&lt;?&gt; loadMyClass(String name) &#123;</span><br><span class="line">        // 将类名中的点改为文件分隔符，并添加.class后缀</span><br><span class="line">        String clzName = name.replace(&quot;.&quot;, File.separator);</span><br><span class="line">        clzName += &quot;.class&quot;;</span><br><span class="line">        // 从文件中读</span><br><span class="line">        String filePath = classPath + File.separator + clzName;</span><br><span class="line">        File file = new File(filePath);</span><br><span class="line">        if (!file.exists()) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        FileInputStream in = null;</span><br><span class="line">        ByteArrayOutputStream out = null;</span><br><span class="line">        byte[] classBytes = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            in = new FileInputStream(file);</span><br><span class="line">            out = new ByteArrayOutputStream();</span><br><span class="line">            byte[] buffer = new byte[1024];</span><br><span class="line">            int size = 0;</span><br><span class="line">            while ((size = in.read(buffer)) != -1) &#123;</span><br><span class="line">                out.write(buffer, 0, size);</span><br><span class="line">            &#125;</span><br><span class="line">            classBytes = out.toByteArray();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            closeQuietly(in);</span><br><span class="line">            closeQuietly(out);</span><br><span class="line">        &#125;</span><br><span class="line">        if (classBytes == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return super.defineClass(name, classBytes, 0, classBytes.length);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 静默关闭</span><br><span class="line">     * @param obj</span><br><span class="line">     */</span><br><span class="line">    private void closeQuietly(Closeable obj) &#123;</span><br><span class="line">        if (obj != null) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                obj.close();</span><br><span class="line">            &#125; catch (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 重写该方法，用于获取资源</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public URL findResource(String name) &#123;</span><br><span class="line">        String path = resourcePath + File.separator + name;</span><br><span class="line">        File file = new File(path);</span><br><span class="line">        if (!file.exists()) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        try &#123;</span><br><span class="line">            return file.toURI().toURL();</span><br><span class="line">        &#125; catch (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 根目录</span><br><span class="line">     */</span><br><span class="line">    private static final String CLASSLOAD_PATH_DIR = &quot;C:\\Users\\Administrator\\Desktop\\testclassload&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 类路径</span><br><span class="line">     */</span><br><span class="line">    private static final String CLASSLOAD_PATH_CLASS = &quot;classes&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 资源路径</span><br><span class="line">     */</span><br><span class="line">    private static final String CLASSLOAD_PATH_RESOURCES = &quot;\\resources&quot;;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        String classPath = CLASSLOAD_PATH_DIR + File.separator + CLASSLOAD_PATH_CLASS;</span><br><span class="line">        String resourcePath = CLASSLOAD_PATH_DIR + File.separator + CLASSLOAD_PATH_RESOURCES;</span><br><span class="line">        MyClassLoader myClassLoader = MyClassLoader.getMyClassLoader(classPath, resourcePath);</span><br><span class="line">        </span><br><span class="line">        // 待加载类，不在当前工程中</span><br><span class="line">        String bookClzName = &quot;com.test.Book&quot;;</span><br><span class="line">        Class&lt;?&gt; bookClz = myClassLoader.loadClass(bookClzName);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;bookClz&apos;s classLoader is : &quot; + bookClz.getClassLoader().getClass().getName());</span><br><span class="line">        </span><br><span class="line">        // 加载后new出实例</span><br><span class="line">        Constructor constructor = bookClz.getConstructor(new Class[] &#123;String.class, double.class&#125;);     </span><br><span class="line">        Method method = bookClz.getMethod(&quot;puzzleTime&quot;);</span><br><span class="line">        if (!method.isAccessible()) &#123;</span><br><span class="line">            method.setAccessible(true);</span><br><span class="line">        &#125;</span><br><span class="line">        method.invoke(constructor.newInstance(new Object[] &#123;&quot;Book0&quot;, 20&#125;));</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 代加载类</span><br><span class="line"> */</span><br><span class="line">public class Book &#123;</span><br><span class="line"></span><br><span class="line">    private String bookName;</span><br><span class="line">    </span><br><span class="line">    private double price;</span><br><span class="line">    </span><br><span class="line">    public Book(String bookName, double price) &#123;</span><br><span class="line">        this.bookName = bookName;</span><br><span class="line">        this.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void puzzleTime() &#123;</span><br><span class="line">        System.out.println(&quot;OK, you found me!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要讲解ClassLoader的含义、jvm类加载机制、ClassLoader类解读和实例。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>mysql触发器</title>
    <link href="http://yoursite.com/2019/12/31/database/mysql%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
    <id>http://yoursite.com/2019/12/31/database/mysql触发器/</id>
    <published>2019-12-31T02:06:39.000Z</published>
    <updated>2020-01-02T11:32:21.516Z</updated>
    
    <content type="html"><![CDATA[<p>mysql触发器创建和使用</p><a id="more"></a><h3 id="mysql触发器类型"><a href="#mysql触发器类型" class="headerlink" title="mysql触发器类型"></a>mysql触发器类型</h3><h3 id="mysql触发器使用"><a href="#mysql触发器使用" class="headerlink" title="mysql触发器使用"></a>mysql触发器使用</h3><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mysql触发器创建和使用&lt;/p&gt;
    
    </summary>
    
    
      <category term="database" scheme="http://yoursite.com/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>【转载】hexo 安装使用</title>
    <link href="http://yoursite.com/2019/12/31/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91hexo-%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/12/31/【转载】hexo-安装使用/</id>
    <published>2019-12-31T01:48:38.000Z</published>
    <updated>2019-12-31T01:58:01.981Z</updated>
    
    <content type="html"><![CDATA[<p>转载hexo安装和使用</p><a id="more"></a><p>详见： <a href="https://cloud.tencent.com/developer/article/1004760" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1004760</a></p><p>记录： </p><ol><li>新建博文： <code>hexo new &quot;new post&quot;</code></li><li>生成静态页面并发布： <code>hexo generate &amp;&amp; hexo deploy</code></li><li>生成的文件位置： <code>/source/_post/</code>和<code>public</code>，因此删除的话，手动删掉这两个文件夹下的内容，然后重新发布即可</li><li>长度控制： <code>&lt;!-- more --&gt;</code></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载hexo安装和使用&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo使用" scheme="http://yoursite.com/tags/hexo%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>https实践</title>
    <link href="http://yoursite.com/2019/10/31/http/https%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2019/10/31/http/https实践/</id>
    <published>2019-10-30T16:00:00.000Z</published>
    <updated>2019-11-14T13:51:49.235Z</updated>
    
    <content type="html"><![CDATA[<p>本文从如下几个方面对https进行阐述：https的原理、认证方式、具体实践和对https请求的java调用。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTPS将HTTP协议与一组强大的对称、非对称和基于证书的加密技术结合在一起，</span><br><span class="line">使得HTTPS不仅很安全，而且很灵活，很容易在处于无序状态、分散的全发球互联网上进行管理。</span><br></pre></td></tr></table></figure><h2 id="https原理"><a href="#https原理" class="headerlink" title="https原理"></a>https原理</h2><p>增加了SSL（Secure Sockets Layer 安全套接层），在进行TCP传输之前，先通过SSL层对数据进行加密，如下图所示。<br><img src="https://s2.ax1x.com/2019/11/01/KT7jC8.png" alt="https增加ssl层"></p><h2 id="认证方式"><a href="#认证方式" class="headerlink" title="认证方式"></a>认证方式</h2><h2 id="具体实践"><a href="#具体实践" class="headerlink" title="具体实践"></a>具体实践</h2><p>一般部署方式：使用HTTPS/HTTP客户端网关，形式如下：<br><img src="https://s2.ax1x.com/2019/11/01/K7tH9e.png" alt="HTTPS/HTTP客户端网关"></p><p>本地模拟https请求，使用Apache做网关，tomcat做应用服务器，配置工作分为如下几步：</p><ol><li>使用openssl生成认证证书</li><li>Apache配置https和转发</li></ol><p>具体来说，openssl生成认证证书的步骤如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 下载并安装OpenSSL（[下载地址](http://slproweb.com/products/Win32OpenSSL.html)）</span><br><span class="line">2. 使用如下命令生成证书</span><br><span class="line">    // 生成服务器端私钥文件：</span><br><span class="line">    openssl genrsa -des3 -out server.key 1024</span><br><span class="line">    // </span><br><span class="line">3. 安装server.crt</span><br></pre></td></tr></table></figure></p><p>Apache启用ssl，并作转发的步骤如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1. 配置转发</span><br><span class="line">    如下两行放开注释：</span><br><span class="line">        #LoadModule proxy_module modules/mod_proxy.so</span><br><span class="line">        #LoadModule proxy_http_module modules/mod_proxy_http.so</span><br><span class="line">    转发规则：</span><br><span class="line">        ProxyPass / http://127.0.0.1:8080</span><br><span class="line">        ProxyPassReverse / http://127.0.0.1:8080</span><br><span class="line">2. 配置https</span><br><span class="line">    放开注释：</span><br><span class="line">        #LoadModule ssl_module modules/mod_ssl.so</span><br><span class="line">        #Include conf/extra/httpd-ssl.conf</span><br><span class="line">    修改httpd-ssl.conf文件，需在&lt;VirtualHost _default_:443&gt;标签中修改：</span><br><span class="line">        ServerName zt-httpstest:443</span><br><span class="line">        SSLCertificateFile &quot;$&#123;SRVROOT&#125;/conf/server.crt&quot;</span><br><span class="line">        SSLCertificateKeyFile &quot;$&#123;SRVROOT&#125;/conf/server.key&quot;</span><br></pre></td></tr></table></figure></p><p>效果：<br><img src="https://s2.ax1x.com/2019/11/01/K7s3KU.png" alt="https效果"></p><h2 id="http请求https"><a href="#http请求https" class="headerlink" title="http请求https"></a>http请求https</h2><p>客户端请求https时，可以让客户端信任所有服务器，也可以让客户端信任特定的服务器。 这里以客户端不验证服务器举例（读取特定服务器证书的方法见引用2）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">import java.io.IOException;</span><br><span class="line">import java.security.SecureRandom;</span><br><span class="line">import java.security.cert.CertificateException;</span><br><span class="line">import java.security.cert.X509Certificate;</span><br><span class="line"></span><br><span class="line">import javax.net.ssl.HostnameVerifier;</span><br><span class="line">import javax.net.ssl.SSLContext;</span><br><span class="line">import javax.net.ssl.SSLSession;</span><br><span class="line">import javax.net.ssl.SSLSocketFactory;</span><br><span class="line">import javax.net.ssl.TrustManager;</span><br><span class="line">import javax.net.ssl.X509TrustManager;</span><br><span class="line"></span><br><span class="line">import okhttp3.MediaType;</span><br><span class="line">import okhttp3.OkHttpClient;</span><br><span class="line">import okhttp3.Request;</span><br><span class="line">import okhttp3.RequestBody;</span><br><span class="line">import okhttp3.Response;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * OKHttp测试</span><br><span class="line"> */</span><br><span class="line">public class OKHttpService &#123;</span><br><span class="line">    </span><br><span class="line">    private OkHttpClient client = new OkHttpClient.Builder()</span><br><span class="line">            .sslSocketFactory(createSSLSocketFactory(), new TrustAllCerts())</span><br><span class="line">            .hostnameVerifier(new TrustAllHostnameVerifier())</span><br><span class="line">            .build();   </span><br><span class="line">    </span><br><span class="line">    private static final MediaType JSON = MediaType.get(&quot;application/json; charset=utf-8&quot;);</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * get请求</span><br><span class="line">     */</span><br><span class="line">    public String get(String url) throws IOException &#123;</span><br><span class="line">        Request request = new Request.Builder()</span><br><span class="line">                .url(url)</span><br><span class="line">                .build();</span><br><span class="line">        Response response = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            response = client.newCall(request).execute();</span><br><span class="line">            return response.body().string();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (response != null) &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * post请求</span><br><span class="line">     */</span><br><span class="line">    public String post(String url, String json) throws IOException &#123;</span><br><span class="line">        if (json == null) &#123;</span><br><span class="line">            json = &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        RequestBody body = RequestBody.create(json.getBytes(), JSON);</span><br><span class="line">        Request request = new Request.Builder()</span><br><span class="line">                .url(url)</span><br><span class="line">                .post(body)</span><br><span class="line">                .build();</span><br><span class="line">        Response response = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            response = client.newCall(request).execute();</span><br><span class="line">            return response.body().string();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (response != null) &#123;</span><br><span class="line">                response.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    private static SSLSocketFactory createSSLSocketFactory() &#123;</span><br><span class="line">        SSLSocketFactory ssf = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            SSLContext sc = SSLContext.getInstance(&quot;TLS&quot;);</span><br><span class="line">            sc.init(null, new TrustManager[] &#123; new TrustAllCerts() &#125;, new SecureRandom());</span><br><span class="line">            ssf = sc.getSocketFactory();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return ssf;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 信任所有的服务器证书</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    static class TrustAllCerts implements X509TrustManager &#123;</span><br><span class="line">        public void checkClientTrusted(java.security.cert.X509Certificate[] var1, String var2)</span><br><span class="line">                throws CertificateException &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void checkServerTrusted(java.security.cert.X509Certificate[] var1, String var2)</span><br><span class="line">                throws CertificateException &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">            return new X509Certificate[0];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">     * 信任所有主机名</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    static class TrustAllHostnameVerifier implements HostnameVerifier &#123;</span><br><span class="line">        public boolean verify(String var1, SSLSession var2) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ol><li>《HTTP权威指南》</li><li><a href="https://blog.csdn.net/sunny2come/article/details/79912024" target="_blank" rel="noopener">OKHttp对Https的认证的处理</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文从如下几个方面对https进行阐述：https的原理、认证方式、具体实践和对https请求的java调用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式--职责链模式</title>
    <link href="http://yoursite.com/2019/04/18/design_pattern/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/18/design_pattern/职责链模式/</id>
    <published>2019-04-17T16:00:00.000Z</published>
    <updated>2019-09-27T03:31:12.467Z</updated>
    
    <content type="html"><![CDATA[<p>行为型设计模式的一种</p><a id="more"></a><h3 id="【DP】定义"><a href="#【DP】定义" class="headerlink" title="【DP】定义"></a>【DP】定义</h3><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，知道有一个对象处理它为止。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>一个请求的处理需要多个对象当中的一个或几个协作处理 </li></ol><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://github.com/tengyuanjack/Blogs/blob/master/attachments/graphs/design-pattern/%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F.png" alt="职责链模式"></p><p>类图核心是：抽象处理类中的设置后继者的方法setSuccessor，并且后继者也是抽象处理类类型。这就产生了一种链式结构。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>假设有个请假的单据，自动审批类包括经理审批类、总经理审批类和CEO审批类，每个自动审批类的权限不同，经理审批类只有三天权限，总经理审批类有七天权限，CEO审批类有半个月权限。</p><p>对于这个请假单据的自动审批，就可以用职责链模式，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请假单据类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voucher</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请假人</span></span><br><span class="line">    <span class="keyword">private</span> String personName;</span><br><span class="line">    <span class="comment">// 请假天数</span></span><br><span class="line">    <span class="keyword">private</span> String leaveDayNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动审批抽象类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsApprove</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 后继者</span></span><br><span class="line">    <span class="keyword">protected</span> AbsApprove successor;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(AbsApprove successor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Voucher voucher)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 经理自动审批类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManagerApprove</span> <span class="keyword">extends</span> <span class="title">AbsApprove</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Voucher voucher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leaveDayNum = voucher.getLeaveDayNum();</span><br><span class="line">        <span class="keyword">if</span> (leaveDayNum &lt;= <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="comment">// approve this voucher</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无权处理，交给下一个职责处理类</span></span><br><span class="line">            <span class="keyword">this</span>.successor.handle(voucher);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 总经理自动审批类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GMApprove</span> <span class="keyword">extends</span> <span class="title">AbsApprove</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Voucher voucher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leaveDayNum = voucher.getLeaveDayNum();</span><br><span class="line">        <span class="keyword">if</span> (leaveDayNum &lt;= <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="comment">// approve this voucher</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无权处理，交给下一个职责处理类</span></span><br><span class="line">            <span class="keyword">this</span>.successor.handle(voucher);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CEO自动审批类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CEOApprove</span> <span class="keyword">extends</span> <span class="title">AbsApprove</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Voucher voucher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> leaveDayNum = voucher.getLeaveDayNum();</span><br><span class="line">        <span class="keyword">if</span> (leaveDayNum &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">            <span class="comment">// approve this voucher</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// reject this voucher</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 声明各个审批类，并制定职责链的下一级</span></span><br><span class="line">        AbsApprove manager = <span class="keyword">new</span> ManagerApprove();</span><br><span class="line">        AbsApprove gm = <span class="keyword">new</span> ManagerApprove();</span><br><span class="line">        AbsApprove ceo = <span class="keyword">new</span> CEOApprove();</span><br><span class="line">        manager.setSuccessor(gm); </span><br><span class="line">        gm.setSuccessor(ceo); </span><br><span class="line"></span><br><span class="line">        Voucher voucher = <span class="keyword">new</span> Voucher(<span class="string">"zhangsan"</span>, <span class="number">20</span>);</span><br><span class="line">        <span class="comment">// 初始时交给经理来处理</span></span><br><span class="line">        manager.handle(voucher);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，客户端可以指定每个职责类的下一级是谁，然后将任务交给最初的职责类处理，不用管最后是谁处理的。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>重点理解两个词：“职责”和“链”，使用这种模式的时候要看各个类能否区分职责，并且是一个链式结构；</li><li>因为客户端可以随意指定职责类的下一级，因此可以实现越级处理的目的。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;行为型设计模式的一种&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式--命令模式</title>
    <link href="http://yoursite.com/2019/04/18/design_pattern/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/18/design_pattern/命令模式/</id>
    <published>2019-04-17T16:00:00.000Z</published>
    <updated>2019-09-27T03:30:00.443Z</updated>
    
    <content type="html"><![CDATA[<p>行为型设计模式的一种</p><a id="more"></a><h3 id="【DP】定义"><a href="#【DP】定义" class="headerlink" title="【DP】定义"></a>【DP】定义</h3><p>将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>当行为的请求者和行为的处理者耦合度太高的时候，需要考虑使用命令模式，将行为以命令类的形式抽离出来，从而将请求者和处理者解耦。</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src alt="命令模式"></p><p>该类图的核心是通过命令接口将行为请求者和行为处理者分开，让请求者只做记录有哪些命令执行的事儿，让处理者只包含处理具体命令的代码，做到二者职责分离并保证职责单一。</p><p>抽离出来的命令类并不真正的执行命令，抽离出来是为了让请求者更好的记录，保证多个命令能够排队、记录或撤销。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;行为型设计模式的一种&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式--观察者模式</title>
    <link href="http://yoursite.com/2019/04/17/design_pattern/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/17/design_pattern/观察者模式/</id>
    <published>2019-04-16T16:00:00.000Z</published>
    <updated>2019-09-27T03:31:24.770Z</updated>
    
    <content type="html"><![CDATA[<p>行为型设计模式的一种</p><a id="more"></a><h3 id="【DP】定义"><a href="#【DP】定义" class="headerlink" title="【DP】定义"></a>【DP】定义</h3><p>定义了一种一对多的依赖关系，让多个观察者对象（Observer）同时监听某一个主题对象（Subject）。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>当一个抽象模型有两个方面, 其中一个方面依赖于另一方面。将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。</li><li>当一个对象的改变需要同时改变其它对象, 而不知道具体有多少对象有待改变。</li><li>当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之, 你不希望这些对象是紧密耦合的。</li></ol><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://github.com/tengyuanjack/Blogs/blob/master/attachments/graphs/design-pattern/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="观察者模式"></p><p>类图核心是：动作主体的三个方法attach、detach和notify方法，以及动作主体对观察者的使用。观察者类以接口的形式注册到动作主体，使用attach和detach进行观察者的添加和移除，notify方法通过调用各个观察者的update方法，起到通知的作用。</p><p>类图中绿色依赖关系表示可有可无，当观察者需要动作主体的状态等信息时可以依赖具体的动作主体类。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>假设当程序出错时需要分别向本地日志、远程日志和控制台上输出错误信息，并且输出位置以后还可能有变化，那么使用观察者模式就非常合适了。设计如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动作主体接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动作主体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubjectImpl</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.writeLog(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">writeLog</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者实现类1---写本地日志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalLogObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLog</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write local log</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者实现类2---写日志服务器上的日志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteLogObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLog</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write remote log</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者实现类3---写控制台</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLog</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// print on console</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 声明动作主体</span></span><br><span class="line">        Subject subject = <span class="keyword">new</span> SubjectImpl();</span><br><span class="line">        <span class="comment">// 注册观察者</span></span><br><span class="line">        subject.attach(<span class="keyword">new</span> LocalLogObserver());</span><br><span class="line">        subject.attach(<span class="keyword">new</span> RemoteLogObserver());</span><br><span class="line">        subject.attach(<span class="keyword">new</span> ConsoleLogObserver());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 一段可能抛异常的代码</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            String msg = e.getMessage();</span><br><span class="line">            <span class="comment">// 调用通知代码</span></span><br><span class="line">            subject.notify(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当有其他的日志打印需求时，可以很方便的注册并在客户端透明的使用。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>当观察者不需要动作主体的状态信息时，观察者完全不依赖动作主体，保证了低耦合。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;行为型设计模式的一种&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式--模板方法模式</title>
    <link href="http://yoursite.com/2019/04/15/design_pattern/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/15/design_pattern/模板方法模式/</id>
    <published>2019-04-14T16:00:00.000Z</published>
    <updated>2019-09-27T03:30:40.905Z</updated>
    
    <content type="html"><![CDATA[<p>行为型设计模式的一种，该模式是对抽象类的使用。</p><a id="more"></a><h3 id="【DP】定义"><a href="#【DP】定义" class="headerlink" title="【DP】定义"></a>【DP】定义</h3><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>有很多子类会写很多相同的代码，为了维护方便和减少代码量，可以使用模板方法模式</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://github.com/tengyuanjack/Blogs/blob/master/attachments/graphs/design-pattern/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt="模板方法模式"></p><p>类图核心是抽象类，将复用的方法放到抽象类中，并用abstract修饰。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>该模式就是对抽象类的使用，没有必要举例子了。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;行为型设计模式的一种，该模式是对抽象类的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式--状态模式</title>
    <link href="http://yoursite.com/2019/04/13/design_pattern/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/13/design_pattern/状态模式/</id>
    <published>2019-04-12T16:00:00.000Z</published>
    <updated>2019-09-27T03:30:46.656Z</updated>
    
    <content type="html"><![CDATA[<p>行为型设计模式的一种</p><a id="more"></a><h3 id="【DP】定义"><a href="#【DP】定义" class="headerlink" title="【DP】定义"></a>【DP】定义</h3><p>当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>一个对象在多个状态下行为不同，且这些状态可以互相转换</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://github.com/tengyuanjack/Blogs/blob/master/attachments/graphs/design-pattern/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.png" alt="状态模式"></p><p>该类图的核心是： 状态管理类和状态接口的聚合关系，以及状态类方法的参数是状态管理类。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>假设单据审批过程的状态包括： 未提交、未审核、已完成三个状态，处于每个状态的单据都需要有不同的处理，具体如下：</p><ol><li>未提交状态的处理是提交，并切换到未审核状态；</li><li>未审核状态的处理是审核，并切换到已完成状态；</li><li>已完成状态的处理是打印单据。</li></ol><p>按照状态模式首先定义状态接口和实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态管理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始状态为未提交</span></span><br><span class="line">        <span class="keyword">this</span>.state = <span class="keyword">new</span> UnCommit();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 外部请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.handle(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未提交</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnCommit</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 做提交</span></span><br><span class="line">        doSomethingToCommit();</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        context.setState(<span class="keyword">new</span> UnApprove());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未审核</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnApprove</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 做审核</span></span><br><span class="line">        doSomethingToApprove();</span><br><span class="line">        <span class="comment">// 修改状态</span></span><br><span class="line">        context.setState(<span class="keyword">new</span> Complete());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 已完成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Complete</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 打印单据</span></span><br><span class="line">        doSomethingToPrint();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端处理如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建状态管理类，并初始为未提交状态</span></span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        <span class="comment">// 第一次请求，执行提交，状态变为未审核状态</span></span><br><span class="line">        context.request();</span><br><span class="line">        <span class="comment">// 第二次请求，执行审核，状态变为已完成状态</span></span><br><span class="line">        context.request();</span><br><span class="line">        <span class="comment">// 第三次请求，执行打印</span></span><br><span class="line">        context.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，客户端在调用时不需要担心当前状态是什么，只需要依次执行请求即可，每个状态有自己的处理和状态切换。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>与策略模式的对比：二者虽然都是行为模式，且类图很像，都是让客户端透明的执行算法策略或者状态操作，但是策略模式是封装了算法的变化，各个算法类之间没有关系，而状态模式是封装了状态的变化，各个状态之间可以转换。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;行为型设计模式的一种&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式--策略模式</title>
    <link href="http://yoursite.com/2019/04/10/design_pattern/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/10/design_pattern/策略模式/</id>
    <published>2019-04-09T16:00:00.000Z</published>
    <updated>2019-09-27T03:30:52.913Z</updated>
    
    <content type="html"><![CDATA[<p>行为型设计模式的一种</p><a id="more"></a><h3 id="【DP】定义"><a href="#【DP】定义" class="headerlink" title="【DP】定义"></a>【DP】定义</h3><p>定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化不会影响到使用算法的客户。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>从定义中可以看出，如果有很多种算法或者执行策略，在客户端的判断会破坏开闭原则，因此在这种情况下可以使用策略模式</li></ol><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://github.com/tengyuanjack/Blogs/blob/master/attachments/graphs/design-pattern/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.png" alt="策略模式"></p><p>类图的核心是： 使用接口封装行为（或者说是封装变化），在上下文类中调用策略的接口。</p><p>其实是对java多态的使用。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>图表是有维度的概念的，但是不同类型维度的处理是不一样的，比如有字段维度和时间分组维度。在拼sql时，字段维度是直接放在group by后的内容，时间分组维度要先进行时间的截取，放到group by后边的应该是对字段的截取后的内容。</p><p>比如：</p><p>要按照组织分组，那么这个是字段维度，sql中是<figure class="highlight plain"><figcaption><span>by pk_org```;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">要按照年分组，那么这个是分组维度，sql中是```group by substr(time, 1, 4) ```, ```substr```是对time字段（对应的值是19位的时间2019-04-10 17:15:20）截前四位。</span><br><span class="line"></span><br><span class="line">那么两种不同维度的处理不同，就可以使用策略模式，代码如下：</span><br><span class="line">```Java</span><br><span class="line">/**</span><br><span class="line"> * 策略接口</span><br><span class="line"> */</span><br><span class="line">public interface Strategy &#123;</span><br><span class="line">    String getGroupByStr(String fieldName);</span><br><span class="line">&#125;</span><br><span class="line">public class FieldStrategy implements Strategy &#123;    </span><br><span class="line">    @Override</span><br><span class="line">    public String getGroupByStr(String fieldName) &#123;</span><br><span class="line">        return fieldName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TimeGroupStrategy implements Strategy &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String getGroupByStr(String fieldName) &#123;</span><br><span class="line">        return &quot;substr(&quot; + fieldName + &quot;, 1, 4)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 使用策略的上下文类</span><br><span class="line"> */</span><br><span class="line">public class StrategyContext &#123;</span><br><span class="line">    private Strategy strategy;</span><br><span class="line">    public StrategyContext(Strategy strategy) &#123;</span><br><span class="line">        this.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getGroupByStr(String fieldName) &#123;</span><br><span class="line">        return strategy.getGroupByStr(fieldName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 客户端</span><br><span class="line"> */</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main() &#123;</span><br><span class="line">        Strategy strategy = new TimeGroupStrategy();</span><br><span class="line">        StrategyContext ctx = new StrategyContext(strategy);</span><br><span class="line">        ctx.getGroupByStr(&quot;abcd&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看完例子之后一定有两个疑问：</p><ol><li>为什么客户端代码还是有需要区分策略类型的代码？</li><li>上下文类的作用是什么，直接调用接口不就可以了吗？</li></ol><p>对第一个问题，客户端的判断逻辑代码是可以挪到简单工厂类，这里我们可以把他挪到上下文类中；</p><p>对第二个问题，上下文类在这个例子中只是调了一下策略接口的方法，然而在实际应用中，接口调用的前后可能需要一些处理，这些就可以在上下文类中实现，同时有选择性地向上层调用暴露方法，使代码更加灵活。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>在理解策略模式的时候应该首先明确它是行为型模式，策略类是对变化的封装;</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;行为型设计模式的一种&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式--原型模式</title>
    <link href="http://yoursite.com/2019/04/09/design_pattern/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/09/design_pattern/原型模式/</id>
    <published>2019-04-08T16:00:00.000Z</published>
    <updated>2019-09-27T03:29:53.588Z</updated>
    
    <content type="html"><![CDATA[<p>创建型设计模式的一种</p><a id="more"></a><h3 id="【DP】定义"><a href="#【DP】定义" class="headerlink" title="【DP】定义"></a>【DP】定义</h3><p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>用于拷贝对象</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://github.com/tengyuanjack/Blogs/blob/master/attachments/graphs/design-pattern/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.png" alt="原型模式"></p><p>核心就是实现Cloneable接口</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>原型模式主要是Cloneable接口的使用，实现简单，多和其他模式共同使用；</li><li>需要注意深克隆和浅克隆的事情，这里不做过多介绍，可以查看<a href="http://note.youdao.com/noteshare?id=5d3dc9c6e07bde4cb676573810effcec&amp;sub=B34DA3B86D594A189691A32B7FF86219" target="_blank" rel="noopener">小知识点</a>中的第六条；</li><li>克隆不会执行构造方法；</li><li>克隆并不会判断方法和对象的访问权限，因此对于单例类，虽然属性和构造方法都是private的，但是仍然会克隆一份，故原型模式和单例模式不能同时使用。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;创建型设计模式的一种&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式--建造者模式</title>
    <link href="http://yoursite.com/2019/04/08/design_pattern/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/08/design_pattern/建造者模式/</id>
    <published>2019-04-07T16:00:00.000Z</published>
    <updated>2019-09-27T03:30:23.993Z</updated>
    
    <content type="html"><![CDATA[<p>创建型设计模式的一种</p><a id="more"></a><h3 id="【DP】定义"><a href="#【DP】定义" class="headerlink" title="【DP】定义"></a>【DP】定义</h3><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>需要构建一批构建过程相同但表示不同的产品，而构建过程非常复杂，为了防止构建过程遗漏步骤，需要建造者模式</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://github.com/tengyuanjack/Blogs/blob/master/attachments/graphs/design-pattern/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="建造者模式"></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>假设有一套单据，结构相同，但是很复杂，每个单据的显示内容各不相同。类结构如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单据类，省略getter、setter方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoice</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LeftHeader leftHeader;</span><br><span class="line">    <span class="keyword">private</span> RightHeader rightHeader;</span><br><span class="line">    <span class="keyword">private</span> LeftBody leftBody;</span><br><span class="line">    <span class="keyword">private</span> RightBody rightBody;</span><br><span class="line">    <span class="keyword">private</span> LeftTail leftTail;</span><br><span class="line">    <span class="keyword">private</span> RightTail rightTail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么为了构建这样一个类，需要调用各个部分的构造方法，因为重复代码太多，很容易在写的过程中遗漏某个部分，因此可以使用建造者模式构建一个Builder接口，将所有的方法封装起来。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function">LeftHeader <span class="title">buildLeftHeader</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">RightHeader <span class="title">buildRightHeader</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 省略其他方法......</span></span><br><span class="line">    <span class="function">Invoice <span class="title">buildInvoice</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在创建不同的单据时，可以创建具体的建造者类，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账单单据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Invoice billInvoice;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BillBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        billInvoice = <span class="keyword">new</span> Invoice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LeftHeader <span class="title">buildLeftHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LeftHeader leftHeader = <span class="keyword">new</span> LeftHeader();</span><br><span class="line">        <span class="comment">// do something with leftHeader</span></span><br><span class="line">        billInvoice.setLeftHeader(leftHeader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RightHeader <span class="title">buildRightHeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RightHeader rightHeader = <span class="keyword">new</span> RightHeader();</span><br><span class="line">        <span class="comment">// do something with rightHeader</span></span><br><span class="line">        billInvoice.setRightHeader(rightHeader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Invoice <span class="title">buildInvoice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> billInvoice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有了接口的约束，就不会少构建Invoice的某个部分了。但是在客户端调用时，仍然会有可能少调用实现的方法，那么就需要建造者模式的核心类Director（指挥者）了，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Invoice <span class="title">buildInvoice</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        builder.buildLeftHeader();</span><br><span class="line">        builder.buildRightHeader();</span><br><span class="line">        <span class="comment">// 省略其他方法......</span></span><br><span class="line">        <span class="keyword">return</span> builder.buildInvoice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端调用Director就可以透明的创建一个对象，而不用担心会少调用某个方法了，客户端代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Builder billBuilder = <span class="keyword">new</span> BillBuilder();</span><br><span class="line">        Director director = <span class="keyword">new</span> Director();</span><br><span class="line">        Invoice billInvoice = director.buildInvoice(billBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>建造者模式主要用于一些复杂对象但是结构相似的对象的构建，上文中的例子只写了billInvoice，当然也可以有stockInvoice等等</li><li>建造者模式在只有一个具体的构建对象（比如只有一个billInvoice）时，可以将建造者的具体实现类和Director指挥者类合并在一起，将Director中的build方法放到建造者具体实现类的build方法中</li><li>和<strong>抽象工厂模式</strong>类似，都能够约束创建对象的过程，让客户端能够透明的创建对象，但是二者的<strong>目的和实现方式</strong>不同：抽象工厂模式是为了抽象实现接口而定义了抽象工厂类，建造者模式是为了复用复杂对象的构建过程，保证客户端不会遗漏对象的某个部分，从而创建了指挥者类。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;创建型设计模式的一种&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式--单例模式</title>
    <link href="http://yoursite.com/2019/04/07/design_pattern/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/07/design_pattern/单例模式/</id>
    <published>2019-04-06T16:00:00.000Z</published>
    <updated>2019-09-27T03:29:46.756Z</updated>
    
    <content type="html"><![CDATA[<p>创建型设计模式的一种</p><a id="more"></a><h3 id="【DP】定义"><a href="#【DP】定义" class="headerlink" title="【DP】定义"></a>【DP】定义</h3><p>保证一个类仅有一个实例，并提供一个访问他的全局访问点。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>需要全局唯一，并维护某个全局变量</li><li>避免对象重复创建，减少内存空间占用</li></ol><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="懒汉模式—非线程安全"><a href="#懒汉模式—非线程安全" class="headerlink" title="懒汉模式—非线程安全"></a>懒汉模式—非线程安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心是：instance和构造方法要私有，getInstance方法要是静态的。</p><h4 id="懒汉模式-使用Double-Check-Locking-—线程安全"><a href="#懒汉模式-使用Double-Check-Locking-—线程安全" class="headerlink" title="懒汉模式(使用Double-Check Locking)—线程安全"></a>懒汉模式(使用Double-Check Locking)—线程安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心是： 两次判空和synchronized的同步。</p><p>两次判空的目的是：当instance存在时，就直接返回。当instance为null时，如果有两个线程同时调用getInstance()方法，他们都会通过第一个if判断，然后会进入加锁的临界区，第一个线程进入后，执行完instance已经有值了，然后第二个线程进入临界区，如果没有第二个if语句，会导致instance会被重新实例化，导致instance不是单例了。</p><h4 id="懒汉模式-静态内部类-—线程安全"><a href="#懒汉模式-静态内部类-—线程安全" class="headerlink" title="懒汉模式(静态内部类)—线程安全"></a>懒汉模式(静态内部类)—线程安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyLoader</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyLoader.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心是： LazyLoader必须是private和static修饰，保证只有Singleton调用。</p><p>这种方式是懒加载模式，只有调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 饿汉模式---线程安全</span><br><span class="line">```Java</span><br><span class="line">public class Singleton &#123;</span><br><span class="line">    private static final Singleton instance = new Singleton();</span><br><span class="line">    private Singleton() &#123;&#125;</span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在类初始化的时候就会初始化instance对象，由于又是final类型的，所以instance不会改变，保证内存中只有一个对象存在。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>尽量使用线程安全的方式实现</li><li>Double-check Locking在使用中依然有问题，原因是在new Singleton()时jvm对字节码的重排序操作。修改方法是给instance增加volatile修饰符，volatile会增加内存屏障，防止重排序。具体可以看<a href="https://www.cnblogs.com/a154627/p/10046147.html" target="_blank" rel="noopener">传统单例模式双重检查锁存在的问题</a>.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;创建型设计模式的一种&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式--工厂模式</title>
    <link href="http://yoursite.com/2019/04/06/design_pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/06/design_pattern/工厂模式/</id>
    <published>2019-04-05T16:00:00.000Z</published>
    <updated>2019-09-27T03:30:15.678Z</updated>
    
    <content type="html"><![CDATA[<p>创建型设计模式的一种</p><a id="more"></a><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>在说工厂模式之前，先说一下简单工厂模式。</p><p>简单工厂模式是为了避免在客户端调用时判断各种复杂逻辑，所有的都放到单独的简单工厂类中处理。</p><h4 id="简单工厂模式举例"><a href="#简单工厂模式举例" class="headerlink" title="简单工厂模式举例"></a>简单工厂模式举例</h4><p>假设数据模型分两种，二维模型(TwoDimModel)和多维模型(MultiDimModel)，各自的处理方式不同，于是客户端需要有如下调用方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理模型的服务接口</span></span><br><span class="line">    IService srv = <span class="keyword">null</span>;</span><br><span class="line">    Model model = <span class="keyword">new</span> TwoDimModel();</span><br><span class="line">    <span class="comment">// Model model = new MultiDimModel();</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"two-dim"</span>.equals(model.getModelType())) &#123;</span><br><span class="line">      srv = <span class="keyword">new</span> TwoDimService();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"multi-dim"</span>.equals(model.getModelType())) &#123;</span><br><span class="line">      srv = <span class="keyword">new</span> MultiDimService();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line">    srv.operate();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，这样就把获取服务的代码和调用方法的代码混在一起了，而且如果很多地方都需要调用IService服务，就会造成很多代码重复，同时会导致维护和修改困难。那么就可以使用简单工厂模式，将获取服务的代码放在工厂类中，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IService <span class="title">createService</span><span class="params">(String modelType)</span> </span>&#123;</span><br><span class="line">    IService srv = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"two-dim"</span>.equals(modelType)) &#123;</span><br><span class="line">      srv = <span class="keyword">new</span> TwoDimService();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"multi-dim"</span>.equals(modelType)) &#123;</span><br><span class="line">      srv = <span class="keyword">new</span> MultiDimService();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> srv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Model model = <span class="keyword">new</span> TwoDimModel();</span><br><span class="line">    <span class="comment">// Model model = new MultiDimModel();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理模型的服务接口</span></span><br><span class="line">    IService srv = ServiceFactory.createService(model.getModelType());</span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line">    srv.operate();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样在获取服务的地方只需要使用ServiceFactory的create方法即可，客户端不需要关注具体是哪个service。</p><h4 id="简单工厂模式类图"><a href="#简单工厂模式类图" class="headerlink" title="简单工厂模式类图"></a>简单工厂模式类图</h4><p><img src="https://github.com/tengyuanjack/Blogs/blob/master/attachments/graphs/design-pattern/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt="简单工厂模式类图"></p><p>该模式的精髓是工厂类的create方法，一般是静态方法。</p><h4 id="简单工厂模式的局限"><a href="#简单工厂模式的局限" class="headerlink" title="简单工厂模式的局限"></a>简单工厂模式的局限</h4><p>当我们增加模型的种类，比如加一个三维模型（非多维模型），那么需要做两件事：1. 增加模型类；2. 在工厂方法中增加if判断。 但是在工厂方法中修改就不满足“开闭原则”了，因为是对修改的是关闭的。所以需要引入下面的工厂模式。</p><h3 id="工厂模式实现上述举例"><a href="#工厂模式实现上述举例" class="headerlink" title="工厂模式实现上述举例"></a>工厂模式实现上述举例</h3><p>工厂模式实现上述举例，只需要将工厂类抽象成接口，然后对每一个服务分别创建工厂方法，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">IService <span class="title">createService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二维模型服务工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoDimSrvFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IService <span class="title">createService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TwoDimService();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多维模型服务工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiDimSrvFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span></span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IService <span class="title">createService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MultiDimService();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Model model = <span class="keyword">new</span> TwoDimModel();</span><br><span class="line">    <span class="comment">// Model model = new MultiDimModel();</span></span><br><span class="line">    <span class="comment">// 服务工厂</span></span><br><span class="line">    IFactory factory = <span class="keyword">new</span> TwoDimSrvFactory();</span><br><span class="line">    <span class="comment">// 处理模型的服务接口</span></span><br><span class="line">    IService srv = factory.createService();</span><br><span class="line">    <span class="comment">// 执行操作</span></span><br><span class="line">    srv.operate();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样在增加一种模型的时候，同样需要做两件事： 1. 创建模型类；2. 创建模型服务的工厂类。这样就避免了在简单工厂方法中对工厂类的侵入和修改。</p><p>但是很明显，这又把对模型的判断放到了客户端调用位置，因此在增加模型的时候会对客户端类进行大量的修改。这就需要<a href="https://github.com/tengyuanjack/Blogs/blob/master/design-pattern/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2B%5B%E6%8A%BD%E8%B1%A1%5D%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">简单工厂模式+抽象工厂模式</a>来更好的解决。</p><h3 id="工厂模式类图"><a href="#工厂模式类图" class="headerlink" title="工厂模式类图"></a>工厂模式类图</h3><p><img src="https://github.com/tengyuanjack/Blogs/blob/master/attachments/graphs/design-pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt="工厂模式类图"></p><p>该类图的核心是创建工厂接口，不同的服务使用对应的工厂方法创建。</p><h3 id="工厂模式【DP】定义"><a href="#工厂模式【DP】定义" class="headerlink" title="工厂模式【DP】定义"></a>工厂模式【DP】定义</h3><p>定义一个用于创建对象的接口(上述的IFactory解耦)，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。</p><h3 id="工厂模式使用场景"><a href="#工厂模式使用场景" class="headerlink" title="工厂模式使用场景"></a>工厂模式使用场景</h3><ol><li>希望工厂与产品的种类对客户端保持透明，给客户端提供一致的操作</li><li>不同的工厂和产品可以提供客户端不同的服务或功能</li></ol><h3 id="工厂模式注意事项"><a href="#工厂模式注意事项" class="headerlink" title="工厂模式注意事项"></a>工厂模式注意事项</h3><ol><li>简单工厂模式和工厂模式都是从一堆产品（服务、模型等）中选择一个使用，工厂模式中的不同的具体工厂类还能提供一些其他功能，从代码隔离角度来说，如果除了获取某一个产品，还需要一些复杂的逻辑实现，那么使用工厂方法更好一些，反之，如果只需要获取某个产品，那使用简单工厂即可。</li><li>再次强调： 使用工厂模式，在客户端调用仍然会使用一些判断，将服务类型判断和客户端调用混在一起，做不到无侵入地增加产品，比较好的方法见<a href="https://github.com/tengyuanjack/Blogs/blob/master/design-pattern/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2B%5B%E6%8A%BD%E8%B1%A1%5D%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">简单工厂模式+抽象工厂模式</a>.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;创建型设计模式的一种&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式--简单工厂模式+【抽象】工厂模式</title>
    <link href="http://yoursite.com/2019/04/06/design_pattern/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F+%5B%E6%8A%BD%E8%B1%A1%5D%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/06/design_pattern/简单工厂模式+[抽象]工厂模式/</id>
    <published>2019-04-05T16:00:00.000Z</published>
    <updated>2019-09-27T03:30:59.056Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式的组合，避免客户端对不同类型的逻辑判断</p><a id="more"></a><p>建议先看<a href="https://github.com/tengyuanjack/Blogs/blob/master/design-pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">工厂模式</a>和<a href="https://github.com/tengyuanjack/Blogs/blob/master/design-pattern/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">抽象工厂模式</a></p><h3 id="核心改动"><a href="#核心改动" class="headerlink" title="核心改动"></a>核心改动</h3><p>将客户端的判断逻辑放到工厂类中。</p><h3 id="需要这种组合的原因"><a href="#需要这种组合的原因" class="headerlink" title="需要这种组合的原因"></a>需要这种组合的原因</h3><p>在<a href="https://github.com/tengyuanjack/Blogs/blob/master/design-pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">工厂模式</a>和<a href="https://github.com/tengyuanjack/Blogs/blob/master/design-pattern/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">抽象工厂模式</a>中已经强调过了，在新增数据模型类型时，客户端仍然需要对模型类型进行判断。而我们知道，简单工厂模式能够把客户端的逻辑判断放到工厂类中，所以使用组合方式能够使变动对客户端透明。</p><h3 id="如何在工厂类中避免复杂的if判断或switch判断"><a href="#如何在工厂类中避免复杂的if判断或switch判断" class="headerlink" title="如何在工厂类中避免复杂的if判断或switch判断"></a>如何在工厂类中避免复杂的if判断或switch判断</h3><p>既然要使用简单工厂方法把客户端的判断放到工厂类中，那么必然会产生大量的if和switch判断，可以使用“注册+反射”的方式避免。</p><p>“注册”只在配置文件中注册类名，“反射”是利用jdk的反射机制构建注册的类。</p><p>使用配置文件就不存在增加类后会侵入工厂类代码的情况了。</p><p>这种方式简化了代码的处理，但是会增加工程部署的复杂性，因此使用者需要trade off。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工厂模式的组合，避免客户端对不同类型的逻辑判断&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式--抽象工厂模式</title>
    <link href="http://yoursite.com/2019/04/06/design_pattern/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/06/design_pattern/抽象工厂模式/</id>
    <published>2019-04-05T16:00:00.000Z</published>
    <updated>2019-09-27T03:30:29.842Z</updated>
    
    <content type="html"><![CDATA[<p>创建型设计模式的一种</p><a id="more"></a><p>建议先看<a href="https://github.com/tengyuanjack/Blogs/blob/master/design-pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">工厂模式</a></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>从一个例子入手更容易理解。</p><p>仍然使用<a href="https://github.com/tengyuanjack/Blogs/blob/master/design-pattern/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">工厂模式</a>中的数据模型的例子，假设由于历史原因，对每一个模型的操作都有两个服务，分别用于查询和修改，代码如下(省略具体方法)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查询接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IQueryService</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二维模型查询实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoDimQueryService</span> <span class="keyword">implements</span> <span class="title">IQueryService</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多维模型查询实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiDimQueryService</span> <span class="keyword">implements</span> <span class="title">IQueryService</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUpdateService</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二维模型修改实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoDimUpdateService</span> <span class="keyword">implements</span> <span class="title">IUpdateService</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多维模型修改实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiDimUpdateService</span> <span class="keyword">implements</span> <span class="title">IUpdateService</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p><p>那么怎么能够做到让客户端不用关心在执行查询或修改时调用的哪个实现类的方法呢？ 这就需要使用抽象工厂模式，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">  <span class="function">IQueryService <span class="title">createQueryService</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">IUpdateService <span class="title">createUpdateService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二维模型工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoDimSrvFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IQueryService <span class="title">createQueryService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TwoDimQueryService();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IUpdateService <span class="title">createUpdateService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> TwoDimUpdateService();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多维模型工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiDimSrvFactory</span> <span class="keyword">implements</span> <span class="title">IFactory</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IQueryService <span class="title">createQueryService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MultiDimQueryService();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IUpdateService <span class="title">createUpdateService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MultiDimUpdateService();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Model model = <span class="keyword">new</span> TwoDimModel();</span><br><span class="line">    <span class="comment">// Model model = new MultiDimModel();</span></span><br><span class="line">    <span class="comment">// 工厂</span></span><br><span class="line">    IFactory factory = <span class="keyword">new</span> TwoDimSrvFactory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询服务</span></span><br><span class="line">    IQeuryService querySrv = factory.createQueryService();</span><br><span class="line">    <span class="comment">// 修改服务</span></span><br><span class="line">    IUpdateService updateSrv = factory.createUpdateService();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，客户端只需要知道是哪个工厂类即可，工厂类中的是对查询和修改的抽象接口。</p><h3 id="上述例子的类图"><a href="#上述例子的类图" class="headerlink" title="上述例子的类图"></a>上述例子的类图</h3><p><img src="https://github.com/tengyuanjack/Blogs/blob/master/attachments/graphs/design-pattern/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" alt="抽象工厂模式类图"></p><p>该类图的核心是工厂接口包括了创建查询服务和修改服务的方法，让具体的工厂类分别实现。因为工厂接口只指定方法，因此叫“抽象工厂模式”。</p><h3 id="【DP】定义"><a href="#【DP】定义" class="headerlink" title="【DP】定义"></a>【DP】定义</h3><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>需要一个接口可以提供一个产品族（即上文说的对不同的模型的服务操作），且不必知道产品的具体种类</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>工厂模式和抽象工厂模式的区别是： 工厂模式只需要提供单一的产品（针对例子中的是模型服务），而抽象工厂模式针对的产品族（针对例子中的是模型的一套服务）。</li><li>可以看到，仍然存在如果增加不同类型的模型后，在客户端的调用要修改的问题，因此需要使用<a href="https://github.com/tengyuanjack/Blogs/blob/master/design-pattern/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2B%5B%E6%8A%BD%E8%B1%A1%5D%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="noopener">简单工厂模式+抽象工厂模式</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;创建型设计模式的一种&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式--享元模式</title>
    <link href="http://yoursite.com/2019/04/04/design_pattern/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/04/design_pattern/享元模式/</id>
    <published>2019-04-03T16:00:00.000Z</published>
    <updated>2019-09-27T03:27:22.529Z</updated>
    
    <content type="html"><![CDATA[<p>结构型设计模式的一种，也叫轻量级模式，故英文名称叫FlyWeight</p><a id="more"></a><h3 id="【DP】定义"><a href="#【DP】定义" class="headerlink" title="【DP】定义"></a>【DP】定义</h3><p>运用共享技术有效地支持大量细粒度的对象。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>使用大量的对象，并且这些对象会造成很大的存储开销时需要使用</li><li>对象大多数状态是外部状态，如果删除外部状态可以使用较少对象来表示，那么可以使用享元模式</li></ol><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://github.com/tengyuanjack/Blogs/blob/master/attachments/graphs/design-pattern/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F.png" alt="享元模式"></p><p>该类图的核心是工厂类，工厂类根据少量的内部状态来获取对象，当对象不存在时才创建。这样就能避免对象的创建数量，其实就是我们常说的“把对象缓存起来”。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>假设有一个按照模板打印的需求，这个需求的使用场景会是短时间内大量用户来打印。如果不对模板对象的数量进行控制，对内存是巨大的考验。使用享元模式设计如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模板接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPrintTemplate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模板类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintTemplate</span> <span class="keyword">implements</span> <span class="title">IPrintTemplate</span></span>&#123;</span><br><span class="line">    <span class="comment">// 模板名称（内部状态）</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintTemplate</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// user是外部状态</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// print with user</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 工厂类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, IPrintTemplate&gt; printTemplateMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 核心方法： 获取对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IPrintTemplate <span class="title">getPrintTemplate</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!printTemplateMap.contains(name)) &#123;</span><br><span class="line">            printTemplateMap.put(name, <span class="keyword">new</span> PrintTemplate(name));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> printTemplateMap.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Factory factory = <span class="keyword">new</span> Factory();</span><br><span class="line">        IPrintTemplate template1 = factory.getPrintTemplate(<span class="string">"模板1"</span>);</span><br><span class="line">        template1.print(<span class="keyword">new</span> User(<span class="string">"用户1"</span>));</span><br><span class="line">        IPrintTemplate template2 = factory.getPrintTemplate(<span class="string">"模板1"</span>);</span><br><span class="line">        template2.print(<span class="keyword">new</span> User(<span class="string">"用户2"</span>));</span><br><span class="line">        IPrintTemplate template3 = factory.getPrintTemplate(<span class="string">"模板1"</span>);</span><br><span class="line">        template3.print(<span class="keyword">new</span> User(<span class="string">"用户3"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端类表示三个不同用户使用同一个查询模板打印，此时只会生成一个模板对象，当模板对象比较占用内存时能极大减少内存消耗。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>类图中的非共享对象是为了表示不是接口的所有实现类都必须共享</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;结构型设计模式的一种，也叫轻量级模式，故英文名称叫FlyWeight&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式--组合模式</title>
    <link href="http://yoursite.com/2019/04/04/design_pattern/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/04/design_pattern/组合模式/</id>
    <published>2019-04-03T16:00:00.000Z</published>
    <updated>2019-09-27T03:31:06.851Z</updated>
    
    <content type="html"><![CDATA[<p>结构型设计模式的一种</p><a id="more"></a><h3 id="【DP】定义"><a href="#【DP】定义" class="headerlink" title="【DP】定义"></a>【DP】定义</h3><p>将对象组合成树形结构以表示“部分-整体”的关系。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>想要表达对象的部分-整体层次结构时，主要是树形结构</li><li>希望客户端调用是能够忽略组合对象和单个对象的不同，能统一使用一套方法</li></ol><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="https://github.com/tengyuanjack/Blogs/blob/master/attachments/graphs/design-pattern/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.png" alt="组合模式"></p><p>该类图的核心是简单类和组合类继承同一个抽象类，即简单类和组合类使用同一套方法，使客户端能够忽略对象的不一致。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>假设要设计一个目录结构，目录中文件夹和文件，文件夹下有文件夹或文件，那么使用组合模式设计就会如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象的目录Component</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsDirFile</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 公共属性，名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在抽象类中声明方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(AbsDirFile dirFile)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(AbsDirFile dirFile)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件夹类，组合类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Directory</span> <span class="keyword">extends</span> <span class="title">AbsDirFile</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;AbsDirFile&gt; subDirFiles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(AbsDirFile dirFile)</span> </span>&#123;</span><br><span class="line">        subDirFiles.add(dirFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(AbsDirFile dirFile)</span> </span>&#123;</span><br><span class="line">        subDirFiles.remove(dirFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">AbsDirFile</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(AbsDirFile dirFile)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(AbsDirFile dirFile)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样设计，对于目录树上的任何一个对象都有同一套接口，就能够避免在客户端判断类型。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>从客户端调用的易用性和简便性上来思考组合模式会更容易理解和记忆</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;结构型设计模式的一种&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>23种设计模式--代理模式</title>
    <link href="http://yoursite.com/2019/04/03/design_pattern/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/04/03/design_pattern/代理模式/</id>
    <published>2019-04-02T16:00:00.000Z</published>
    <updated>2019-09-27T03:27:38.569Z</updated>
    
    <content type="html"><![CDATA[<p>结构型设计模式的一种，可分为静态代理模式和动态代理模式</p><a id="more"></a><h3 id="【DP】定义"><a href="#【DP】定义" class="headerlink" title="【DP】定义"></a>【DP】定义</h3><p>为其他对象提供一种代理以控制对这个对象的访问</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>客户类不想或不能直接引用一个委托对象</li><li>需要在已有的功能前后加一些功能，如日志打印等，即扩展委托类功能</li><li>远程过程调用</li></ol><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><strong>静态代理模式：</strong></p><p><img src="https://github.com/tengyuanjack/Blogs/blob/master/attachments/graphs/design-pattern/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F---%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86.png" alt="代理模式---静态代理"></p><p>可以看到，静态代理模式很像适配器模式，二者都有复用功能的作用，但是有区别，静态代理会修改一部分原有的功能，而适配器模式一般会全部复用，并且适配器会将复用的类适配一个接口。</p><p><strong>动态代理模式(JDK实现，用于代理接口)：</strong></p><p><img src="https://github.com/tengyuanjack/Blogs/blob/master/attachments/graphs/design-pattern/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F---%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86.png" alt="代理模式---动态代理"></p><p>可以看到，使用JDK实现的动态代理并不直接引用接口（在运行时根据对象的实际类型去动态执行，可以看下边的代码举例来理解）。</p><p><strong>动态代理模式(CGLIB使用字节码实现，可以直接代理类)：</strong></p><p><img src="https://github.com/tengyuanjack/Blogs/blob/master/attachments/graphs/design-pattern/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F---%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglib.png" alt="代理模式---动态代理2"></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p><strong>静态代理</strong></p><p>假设现在有一个查询的服务，但是在调用这个服务时需要将用户信息绑定到线程本地变量（ThreadLocal）中，那么可以按照如下的方法做：<br>查询服务接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IQueryService</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">query</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>查询服务实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryServiceImpl</span> <span class="keyword">implements</span> <span class="title">IQueryService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//TODO 查查查</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用于真正调用的代理类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> <span class="keyword">implements</span> <span class="title">IQueryService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 被代理类</span></span><br><span class="line">    <span class="keyword">private</span> IQueryService srv;</span><br><span class="line">    <span class="comment">// 通过某种方法获取线程本地变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StaticProxy</span> <span class="params">(IQueryService srv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.srv = srv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        threadLocal.set(<span class="string">"userId"</span>);</span><br><span class="line">        srv.query();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main() &#123;</span><br><span class="line">        IQueryService queryService = new StaticProxy();</span><br><span class="line">        Object res = queryService.query();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就可以实现在查询服务中拿到线程本地变量中的userId了，但是有没有发现代理类StaticProxy和查询的接口严格关联了，此时想要在打印的接口同样增加相同的线程变量，又得写一个代理类（把所有的方法都抽成一个接口，也存在增加接口后无法代理的问题），因此动态代理模式应运而生。</p><p><strong>动态代理（JDK实现）</strong></p><p>同样是对查询接口的执行线程中绑定userId信息，使用动态代理应该按照如下方法做：<br>用于真正调用的代理类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 被代理对象</span></span><br><span class="line">    <span class="keyword">private</span> Object proxyObj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过某种方法获取线程本地变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object proxyObj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.proxyObj = proxyObj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        threadLocal.set(<span class="string">"userId"</span>);</span><br><span class="line">        method.invoke(proxyObj, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 被代理的接口</span></span><br><span class="line">        IQueryService queryService = <span class="keyword">new</span> QueryServiceImpl();</span><br><span class="line">        <span class="comment">// 确定要代理的类</span></span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> DynamicProxy(queryService);</span><br><span class="line">        <span class="comment">// 创建代理实例</span></span><br><span class="line">        IQueryService proxyService = (IQueryService) Proxy.newProxyInstance(IQueryService.class.getClassLoader(), </span><br><span class="line">        <span class="keyword">new</span> Class[] &#123;IQueryService.class&#125;, handler);</span><br><span class="line">        <span class="comment">// 调用</span></span><br><span class="line">        Object result = proxyService.query();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>动态代理类只需实现InvocationHandler，在调用的时候使用Proxy生成代理实例即可，这样就和具体的接口解耦了。可以看到，Proxy在新建代理实例时，需要ClassLoader和接口类，jvm会在运行时根据类型找到实际的类型。</p><p>由于这种方式只能代理接口，但是如果有一些类没有接口，又需要代理，就只能使用下面的CGLIB来实现了。</p><p><strong>动态代理（CGLIB实现）</strong></p><p>假设<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">```Java</span><br><span class="line">public class QueryService &#123;</span><br><span class="line">  // 普通方法</span><br><span class="line">  public Object query() &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">  // final方法</span><br><span class="line">  public final Object finalQuery() &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用于真正调用的代理类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">  <span class="comment">// 业务类对象，供代理方法中进行真正的业务方法调用</span></span><br><span class="line">  <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过某种方法获取线程本地变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; threadLocal;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建代理类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    <span class="comment">//创建加强器，用来创建动态代理类</span></span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    <span class="comment">// 为生成的代理类指定父类</span></span><br><span class="line">    enhancer.setSuperclass(<span class="keyword">this</span>.target.getClass());</span><br><span class="line">    <span class="comment">// 设置回调：对于代理类上所有方法的调用，都会调用CallBack</span></span><br><span class="line">    <span class="comment">// 而Callback则需要实现intercept()方法进行拦截</span></span><br><span class="line">    enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 创建动态代理类对象并返回</span></span><br><span class="line">    <span class="keyword">return</span> enhancer.create();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, </span></span></span><br><span class="line"><span class="function"><span class="params">    MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="comment">// 设置线程本地变量</span></span><br><span class="line">    threadLocal.set(<span class="string">"userId"</span>);</span><br><span class="line">    proxy.invokeSuper(obj, args);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLIBMain</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    QueryService srv = <span class="keyword">new</span> QueryService();</span><br><span class="line">    DynamicProxy cglib = <span class="keyword">new</span> DynamicProxy();</span><br><span class="line">    QueryService proxyService = (QueryService) cglib.getInstance(srv);</span><br><span class="line">    <span class="comment">// 会被代理</span></span><br><span class="line">    Object result = proxyService.query();</span><br><span class="line">    <span class="comment">// final方法，不会被代理</span></span><br><span class="line">    Object result2 = proxyService.finalQuery();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，动态代理类实现了<code>MethodInterceptor</code>，是因为使用<code>Enhancer</code>创建子类时需要使用拦截器。</p><p>在<code>QueryService</code>中的final方法不会被代理，因为生成子类时不能重写final方法。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>1.动态代理使用Proxy新建代理实例时，第二个参数是接口类的数组，说明该种方式只能代理接口，不能代理具体类。原因是所有通过这种方式生成的类会以Proxy作为父类，如果该类有其他的父类，会不符合Java中单继承的规则。</p><p>Proxy类的注释第一段说明了这一点：</p><pre><code>Proxy provides static methods for creating dynamic proxy classes and instances,and it is also the superclass of all dynamic proxy classes created by those methods. </code></pre><p>2.关于动态代理的两种实现对比：<br>2.1. JDK动态代理是实现了被代理对象的接口，Cglib是继承了被代理对象。<br>2.2. JDK和Cglib都是在运行期生成字节码，JDK是直接写Class字节码，Cglib使用ASM框架写Class字节码，Cglib代理实现更复杂，生成代理类比JDK效率低。<br>2.3. JDK调用代理方法，是通过反射机制调用，Cglib是通过FastClass机制直接调用方法，Cglib执行效率更高。</p><p><em>Reference:</em></p><p><em>1.<a href="https://www.cnblogs.com/ygj0930/p/6542259.html" target="_blank" rel="noopener">Java动态代理之JDK实现和CGlib实现（简单易懂）</a></em></p><p><em>2.<a href="https://www.cnblogs.com/monkey0307/p/8328821.html" target="_blank" rel="noopener">Cglib动态代理实现方式</a></em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;结构型设计模式的一种，可分为静态代理模式和动态代理模式&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
